---
title: "build_components"
author: "Will McCarthy"
date: "2024-01-10"
output: html_document
---

```{r}
library(tidyverse)
library(lme4)
# library(lmerTest)
library(ggthemes)
library(performance) 
library(see)
library(lmerTest)
library(effsize)

```


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```

# E1: Recognition (old-new)

```{r import}
# import VSS dataset

experiment.results.dir = '../../results/recognition/csv/'

df.recog <- read_csv(paste(experiment.results.dir, 'df_recog_vss.csv', sep=''))

df.recog <- df.recog %>%
  mutate(responded_old = 1*(response_meaning == 'old')) %>% 
  mutate(is_target = 1*(condition != 'foil'))

df.recog

# df.dprimes <- read_csv('../../results/build_components/csv/df_condition_measures_build_components_pilot_2.csv')

# df.dprimes
```

## Mixed effects linear models

### Predicting response from condition
```{r lmer.condition}
m1 <- glmer(data = df.recog, family = binomial, responded_old ~ is_target + (1 | gameID) + (1 | tower_id))
m2 <- glmer(data = df.recog, family = binomial, responded_old ~ condition + is_target + (1 | gameID) + (1 | tower_id))
m3 <- glmer(data = df.recog, family = binomial, responded_old ~ condition * is_target + (1 | gameID) + (1 | tower_id))
anova(m1, m2, m3)
summary(m3)

# confint(m2, level = 0.95)

```

### Predicting response from condition and type
```{r lmer.condition}
m1 <- glmer(data = df.recog, family = binomial, respond_old ~ (1 | gameID) + (1 | tower_id))
m2 <- glmer(data = df.recog, family = binomial, respond_old ~ distractorKind + (1 | gameID) + (1 | tower_id))
anova(m1, m2)
summary(m2)

# confint(m2, level = 0.95)

```



### By d' (not currently used)

Intercept shows that ppts do recognize towers they have previously experienced.
Slope on condition shows that participants are more likely to recognize viewed towers than built towers.
```{r d.prime.lmers}
# m1 <- lm(data = df.dprimes, d_prime ~ condition)
# anova(m1)
# summary(m1)
# 
# confint(m1, level = 0.95)
```


# E2: Recall

## Import data

```{r import}
# import VSS dataset
experiment.results.dir = '../../results/recall/csv/'

df.recall.vss <- read_csv(paste(experiment.results.dir, 'df_encode_with_recalls_vss.csv', sep=''))
# 
# df.recall <- df.recall %>%
#   mutate(respond_old = 1*(response_meaning == 'old'))

df.recall.vss

df.recall.vss <- df.recall.vss %>% 
  mutate(
    condition = relevel(as_factor(condition), ref = "view")
  )

```

### Predicting match vs. non-match from condition
```{r lmer.condition}
m1 <- glmer(data = df.recall.vss, family = binomial, matched_to_any ~ (1 | gameID))
m2 <- glmer(data = df.recall.vss, family = binomial, matched_to_any ~ condition + (1 | gameID))
anova(m1, m2)
summary(m2)

# confint(m2, level = 0.95)

```
### Predicting perfect recall from condition
```{r lmer.condition}
m1 <- glmer(data = df.recall.vss, family = binomial, perfectly_recalled ~ (1 | gameID))
m2 <- glmer(data = df.recall.vss, family = binomial, perfectly_recalled ~ condition + (1 | gameID))
anova(m1, m2)
summary(m2)

# confint(m2, level = 0.95)

```


### Predicting F1 score from condition
```{r lmer.condition}
m1 <- lmer(data = df.recall.vss, bestMatchScore ~ (1 | gameID) + (1 | tower_id))
m2 <- lmer(data = df.recall.vss, bestMatchScore ~ condition + (1 | gameID) + (1 | tower_id))
anova(m1, m2)
summary(m2)

# confint(m2, level = 0.95)

```
### Predicting F1 score from condition
```{r lmer.condition}
m1 <- lmer(data = df.recall.vss, f1_score ~ condition + (1 | gameID))
# m2 <- lmer(data = df.recall, f1_score ~ condition + (1 | gameID) + (1 | tower_id))
# anova(m1, m2)
summary(m1)

# confint(m2, level = 0.95)

```

```{r}
experiment.results.dir = '../../results/recall/csv/'

dfBestMatch <- read_csv(paste(experiment.results.dir, 'df_best_match_recalls_vss.csv', sep=''))

conditionScoreDiffs <- 
  dfBestMatch %>% 
  filter(built_both) %>% 
  group_by(gameID)  %>%
    summarise(diff = bestMatchScoreMean[bestMatchCondition == 'build'] -
                      bestMatchScoreMean[bestMatchCondition == 'view'], .groups = "drop")

conditionScoreDiffs
```

```{r}
buildScoreFiltered <-
  dfBestMatch %>% 
  filter(built_both, bestMatchCondition == 'build')


viewScoreFiltered <-
  dfBestMatch %>% 
  filter(built_both, bestMatchCondition == 'view')

```

Paired t-test
```{r}
t.test(buildScoreFiltered$bestMatchScoreMean, viewScoreFiltered$bestMatchScoreMean, paired=TRUE)
```
Cohen's d
```{r}
cohens_d <- cohen.d(buildScoreFiltered$bestMatchScoreMean, viewScoreFiltered$bestMatchScoreMean)
cohens_d

```





# E3 Encoding Type on Recognition

```{r import}
experiment.results.dir = '../../results/build_components/cogsci24/'

df.recog.both <- read_csv(paste(experiment.results.dir, 'df_recog_both.csv', sep=''))

df.recog.both$encode_type <- as.factor(df.recog.both$encode_type)
df.recog.both$condition <- as.factor(df.recog.both$condition)

df.recog.both <- df.recog.both %>% 
  mutate(responded_old = 1*(response_meaning == 'old')) %>% 
  mutate(is_target = 1*(condition != 'foil')) %>% 
  mutate(
    encode_type = relevel(encode_type, ref = "ve"),
    condition = relevel(condition, ref = "view")
  )

```
### Predicting response from condition
```{r lmer.condition}
m1 <- glmer(data = df.recog.both, family = binomial, responded_old ~ is_target + (1 | gameID))
m2 <- glmer(data = df.recog.both, family = binomial, responded_old ~ condition + is_target + (1 | gameID))
m3 <- glmer(data = df.recog.both, family = binomial, responded_old ~ condition * is_target + (1 | gameID))
anova(m1, m2, m3)
summary(m3)

# confint(m2, level = 0.95)

```






# E4 Encoding Type on Recall

```{r import}
experiment.results.dir = '../../results/build_components/cogsci24/'

df.recall.both <- read_csv(paste(experiment.results.dir, 'df_encode_with_recalls_both.csv', sep=''))

df.recall.both$encode_type <- as.factor(df.recall.both$encode_type)
df.recall.both$condition <- as.factor(df.recall.both$condition)


df.recall.both <- df.recall.both %>% 
  mutate(
    encode_type = relevel(encode_type, ref = "ve"),
    condition = relevel(condition, ref = "view")
  )
```
```{r glmer.attempted.condition}
m1 <- glmer(data = df.recall.both, family = binomial, attempted_recall ~ encode_type + (1 | gameID))
m2 <- glmer(data = df.recall.both, family = binomial, attempted_recall ~ encode_type + condition + (1 | gameID) )
m3 <- glmer(data = df.recall.both, family = binomial, attempted_recall ~ encode_type * condition + (1 | gameID) )
anova(m1, m2, m3)
summary(m3)

# confint(m2, level = 0.95)

```


```{r glmer.perfect.condition}
m1 <- glmer(data = df.recall.both, family = binomial, perfectly_recalled ~ encode_type + (1 | gameID) + (1 | tower_id))
m2 <- glmer(data = df.recall.both, family = binomial, perfectly_recalled ~ encode_type + condition + (1 | gameID) + (1 | tower_id))
m3 <- glmer(data = df.recall.both, family = binomial, perfectly_recalled ~ encode_type * condition + (1 | gameID) + (1 | tower_id))
anova(m1, m2, m3)
summary(m3)

# confint(m2, level = 0.95)

```
```{r lmer.perfect.condition}
m1 <- lmer(data = df.recall.both, score ~ encode_type + (1 | gameID) + (1 | tower_id))
m2 <- lmer(data = df.recall.both, score ~ encode_type + condition + (1 | gameID) + (1 | tower_id))
m3 <- lmer(data = df.recall.both, score ~ encode_type * condition + (1 | gameID) + (1 | tower_id))
anova(m1, m2, m3)
summary(m3)

# confint(m2, level = 0.95)

```


